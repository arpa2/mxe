diff -Naur a/include/tlspool/internal.h b/include/tlspool/internal.h
--- a/include/tlspool/internal.h	2016-08-24 08:57:20.000000000 +0200
+++ b/include/tlspool/internal.h	2016-10-01 16:04:35.000000000 +0200
@@ -18,7 +18,6 @@
 
 #define CERTS_MAX_DEPTH 10
 
-
 /* A simple (data*,size) construct named pool_datum_t
  */
 typedef struct pool_datum {
diff -Naur a/include/tlspool/starttls.h b/include/tlspool/starttls.h
--- a/include/tlspool/starttls.h	2016-08-24 08:57:20.000000000 +0200
+++ b/include/tlspool/starttls.h	2016-10-01 16:26:28.000000000 +0200
@@ -59,6 +59,10 @@
 } PIPEINST, *LPPIPEINST;
 typedef LPPIPEINST pool_handle_t;
 #define INVALID_POOL_HANDLE NULL
+/* windows/namedpipe.c */
+pool_handle_t open_named_pipe (LPCTSTR lpszPipename);
+int np_send_command(pool_handle_t poolfd, struct tlspool_command *cmd);
+int np_recv_command(pool_handle_t poolfd, struct tlspool_command *cmd);
 #else /* WINDOWS_PORT */
 typedef int pool_handle_t;
 #define INVALID_POOL_HANDLE -1
diff -Naur a/lib/libtlspool.c b/lib/libtlspool.c
--- a/lib/libtlspool.c	2016-08-24 08:57:20.000000000 +0200
+++ b/lib/libtlspool.c	2016-10-01 16:33:38.000000000 +0200
@@ -34,12 +34,9 @@
 #endif
 
 #ifdef WINDOWS_PORT
-#define PIPE_TIMEOUT 5000
-#define BUFSIZE 4096
 #define random rand
 #define srandom srand
 
-#define _tprintf printf
 #endif /* WINDOWS_PORT */
 
 /* The master thread will run the receiving side of the socket that connects
@@ -280,111 +277,6 @@
 	pthread_mutex_unlock (&registry_lock);
 }
 
-#ifdef WINDOWS_PORT
-static pool_handle_t open_named_pipe (LPCTSTR lpszPipename)
-{
-	HANDLE hPipe;
-	//struct tlspool_command chBuf;
-	BOOL   fSuccess = FALSE;
-	DWORD  dwMode;
-
-	// Try to open a named pipe; wait for it, if necessary.
-
-	while (1)
-	{
-		hPipe = CreateFile(
-			lpszPipename,   // pipe name
-			GENERIC_READ |  // read and write access
-			GENERIC_WRITE,
-			0,              // no sharing
-			NULL,           // default security attributes
-			OPEN_EXISTING,  // opens existing pipe
-			FILE_FLAG_OVERLAPPED, // overlapped
-			NULL);          // no template file
-
-		// Break if the pipe handle is valid.
-		if (hPipe != INVALID_POOL_HANDLE)
-			break;
-
-		// Exit if an error other than ERROR_PIPE_BUSY occurs.
-		if (GetLastError() != ERROR_PIPE_BUSY)
-		{
-			_tprintf(TEXT("Could not open pipe. GLE=%d\n"), GetLastError());
-			return INVALID_POOL_HANDLE;
-		}
-
-		// All pipe instances are busy, so wait for 20 seconds.
-		if (!WaitNamedPipe(lpszPipename, 20000))
-		{
-			printf("Could not open pipe: 20 second wait timed out.");
-			return INVALID_POOL_HANDLE;
-		}
-	}
-	// The pipe connected; change to message-read mode.
-	dwMode = PIPE_READMODE_MESSAGE;
-	fSuccess = SetNamedPipeHandleState(
-		hPipe,    // pipe handle
-		&dwMode,  // new pipe mode
-		NULL,     // don't set maximum bytes
-		NULL);    // don't set maximum time
-	if (!fSuccess)
-	{
-		_tprintf(TEXT("SetNamedPipeHandleState failed. GLE=%d\n"), GetLastError());
-		return INVALID_POOL_HANDLE;
-	}
-	ULONG ServerProcessId;
-	if (GetNamedPipeServerProcessId(hPipe, &ServerProcessId)) {
-		printf("GetNamedPipeServerProcessId: ServerProcessId = %ld\n", ServerProcessId);
-	} else {
-		_tprintf(TEXT("GetNamedPipeServerProcessId failed. GLE=%d\n"), GetLastError());
-	}
-	return hPipe;
-}
-
-static int np_send_command(struct tlspool_command *cmd) {
-	DWORD  cbToWrite, cbWritten;
-	OVERLAPPED overlapped;
-	BOOL fSuccess;
-
-	/* Send the request */
-	// Send a message to the pipe server.
-
-	cbToWrite = sizeof (struct tlspool_command);
-	_tprintf(TEXT("Sending %d byte cmd\n"), cbToWrite);
-
-	memset(&overlapped, 0, sizeof(overlapped));
-	overlapped.hEvent = CreateEvent(NULL, TRUE, FALSE, NULL);
-
-	fSuccess = WriteFile(
-		poolfd,                  // pipe handle
-		cmd,                    // cmd message
-		cbToWrite,              // cmd message length
-		NULL,                  // bytes written
-		&overlapped);            // overlapped
-
-	if (!fSuccess && GetLastError() == ERROR_IO_PENDING )
-	{
-// printf ("DEBUG: Write I/O pending\n");
-		fSuccess = WaitForSingleObject(overlapped.hEvent, INFINITE) == WAIT_OBJECT_0;
-	}
-
-	if (fSuccess) {
-		fSuccess = GetOverlappedResult(poolfd, &overlapped, &cbWritten, TRUE);
-	}
-
-	if (!fSuccess)
-	{
-		_tprintf(TEXT("WriteFile to pipe failed. GLE=%d\n"), GetLastError());
-		errno = EPIPE;
-		return -1;
-	} else {
-// printf ("DEBUG: Wrote %ld bytes to pipe\n", cbWritten);
-	}
-// printf("DEBUG: Message sent to server, receiving reply as follows:\n");
-	return 0;
-}
-#endif /* WINDOWS_PORT */
-
 /* The master thread issues the recv() commands on the TLS Pool socket, and
  * redistributes the result to the registry entries that are waiting for
  * the data.  The thread is started when the poolfd is first requested.
@@ -499,36 +391,7 @@
 		while (1) {
 			int retval;
 #ifdef WINDOWS_PORT
-			OVERLAPPED overlapped;
-
-			memset(&overlapped, 0, sizeof(overlapped));
-			overlapped.hEvent = CreateEvent(NULL, TRUE, FALSE, NULL);
-
-			// Read from the pipe.
-			fSuccess = ReadFile(
-				poolfd,       // pipe handle
-				&cmd,         // buffer to receive reply
-				sizeof (cmd), // size of buffer
-				NULL,         // number of bytes read
-				&overlapped); // not overlapped
-
-			if (!fSuccess && GetLastError() == ERROR_IO_PENDING )
-			{
-// printf ("DEBUG: Read I/O pending\n");
-				fSuccess = WaitForSingleObject(overlapped.hEvent, INFINITE) == WAIT_OBJECT_0;
-			}
-
-			if (fSuccess) {
-				fSuccess = GetOverlappedResult(poolfd, &overlapped, &cbRead, TRUE);
-			}
-
-			if (!fSuccess)
-			{
-				_tprintf(TEXT("ReadFile from pipe failed. GLE=%d\n"), GetLastError());
-				retval = -1;
-			} else {
-// printf ("DEBUG: Read %ld bytes from pipe\n", cbRead);
-			}
+			retval = np_recv_command(poolfd, &cmd);
 #else
 			iov.iov_base = &cmd;
 			iov.iov_len = sizeof (cmd);
@@ -565,7 +428,7 @@
 					cmd.pio_data.pioc_error.tlserrno = EPIPE;
 					strncpy (cmd.pio_data.pioc_error.message, "Client prematurely left TLS Pool negotiations", sizeof (cmd.pio_data.pioc_error.message));
 #ifdef WINDOWS_PORT
-					np_send_command (&cmd);
+					np_send_command (poolfd, &cmd);
 #else
 					sendmsg (poolfd, &mh, MSG_NOSIGNAL);
 #endif
@@ -657,7 +520,7 @@
 	cmd.pio_cmd = PIOC_PING_V2;
 	memcpy (&cmd.pio_data.pioc_ping, pingdata, sizeof (struct pioc_ping));
 #ifdef WINDOWS_PORT
-	if (np_send_command (&cmd) == -1) {
+	if (np_send_command (poolfd, &cmd) == -1) {
 		// errno inherited from np_send_command ()
 		registry_update (&entry_reqid, NULL);
 		return -1;
@@ -874,7 +737,7 @@
 #endif /* WINDOWS_PORT */
 	}
 #ifdef WINDOWS_PORT
-	if (np_send_command (&cmd) == -1) {
+	if (np_send_command (poolfd, &cmd) == -1) {
 		close (cryptfd);
 		registry_update (&entry_reqid, NULL);
 		// errno inherited from np_send_command ()
@@ -980,7 +843,7 @@
 			/* Now supply plainfd in the callback response */
 			sentfd = plainfd;
 #ifdef WINDOWS_PORT
-			if (np_send_command (&cmd) == -1) {
+			if (np_send_command (poolfd, &cmd) == -1) {
 				if (sentfd >= 0) {
 					closesocket(sentfd);
 					sentfd = -1;
@@ -1058,7 +921,7 @@
 // printf ("DEBUG: Using control key %02x %02x %02x %02x %02x %02x %02x %02x %02x %02x %02x %02x %02x %02x %02x %02x\n", cmd.pio_data.pioc_control.ctlkey [0], cmd.pio_data.pioc_control.ctlkey [1], cmd.pio_data.pioc_control.ctlkey [2], cmd.pio_data.pioc_control.ctlkey [3], cmd.pio_data.pioc_control.ctlkey [4], cmd.pio_data.pioc_control.ctlkey [5], cmd.pio_data.pioc_control.ctlkey [6], cmd.pio_data.pioc_control.ctlkey [7], cmd.pio_data.pioc_control.ctlkey [8], cmd.pio_data.pioc_control.ctlkey [9], cmd.pio_data.pioc_control.ctlkey [10], cmd.pio_data.pioc_control.ctlkey [11], cmd.pio_data.pioc_control.ctlkey [12], cmd.pio_data.pioc_control.ctlkey [13], cmd.pio_data.pioc_control.ctlkey [14], cmd.pio_data.pioc_control.ctlkey [15]);
 
 #ifdef WINDOWS_PORT
-	if (np_send_command (&cmd) == -1) {
+	if (np_send_command (poolfd, &cmd) == -1) {
 		registry_update (&entry_reqid, NULL);
 		// errno inherited from np_send_command ()
 		return -1;
@@ -1185,7 +1048,7 @@
 	}
 
 #ifdef WINDOWS_PORT
-if (np_send_command (&cmd) == -1) {
+if (np_send_command (poolfd, &cmd) == -1) {
 	// errno inherited from np_send_command ()
 	registry_update (&entry_reqid, NULL);
 	return -1;
diff -Naur a/lib/libtlspool_lidentry.c b/lib/libtlspool_lidentry.c
--- a/lib/libtlspool_lidentry.c	2016-08-24 08:57:20.000000000 +0200
+++ b/lib/libtlspool_lidentry.c	2016-10-01 16:50:04.000000000 +0200
@@ -10,11 +10,16 @@
 #include <unistd.h>
 #include <pthread.h>
 
+
+#ifdef WINDOWS_PORT
+#include <winsock2.h>
+#else
 #include <sys/types.h>
 #include <sys/socket.h>
 #include <sys/un.h>
 #include <sys/select.h>
 #include <sys/resource.h>
+#endif
 
 #include <tlspool/starttls.h>
 #include <tlspool/commands.h>
@@ -22,9 +27,9 @@
 
 /* Cleanup routine */
 static void tlspool_localid_service_closepool (void *poolfdptr) {
-	int poolfd = * (int *) poolfdptr;
-	if (poolfd >= 0) {
-		close (poolfd);
+	pool_handle_t poolfd = * (pool_handle_t  *) poolfdptr;
+	if (poolfd != INVALID_POOL_HANDLE) {
+		tlspool_close_poolhandle (poolfd);
 	}
 }
 
@@ -51,11 +56,22 @@
  * This function returns -1 on error, or 0 on success.
  */
 int tlspool_localid_service (char *path, uint32_t regflags, int responsetimeout, char * (*cb) (lidentry_t *entry, void *data), void *data) {
+#ifdef WINDOWS_PORT
+printf("tlspool_localid_service(%s, %d, %d, %p, %p)\n", path, regflags, responsetimeout, cb, data);
+#else
 	struct sockaddr_un sun;
-	int poolfd = -1;
+#endif
+	pool_handle_t poolfd = INVALID_POOL_HANDLE;
 	struct tlspool_command cmd;
 	char *cberr = NULL;
 
+#ifdef WINDOWS_PORT
+	poolfd = open_named_pipe ((LPCTSTR) path);
+	printf ("DEBUG: poolfd = %d\n", poolfd);
+	if (poolfd == INVALID_POOL_HANDLE) {
+		return -1;
+	}
+#else
 	/* Access the TLS Pool socket */
 	if (path == NULL) {
 		path = tlspool_configvar (NULL, "daemon_pidfile");
@@ -80,7 +96,7 @@
 		poolfd = -1;
 		return -1;
 	}
-
+#endif
 	/* Prepare command structure */
 	memset (&cmd, 0, sizeof (cmd));	/* Do not leak old stack info */
 	cmd.pio_cbid = 0;
@@ -92,22 +108,30 @@
 	while (1) {
 
 		/* send the request or, when looping, the callback result */
-//DEBUG// printf ("DEBUG: LIDENTRY command 0x%08lx with cbid=%d and flags 0x%08lx\n", cmd.pio_cmd, cmd.pio_cbid, cmd.pio_data.pioc_lidentry.flags);
+ printf ("DEBUG: LIDENTRY command 0x%08lx with cbid=%d and flags 0x%08lx\n", cmd.pio_cmd, cmd.pio_cbid, cmd.pio_data.pioc_lidentry.flags);
+#ifdef WINDOWS_PORT
+		if (np_send_command(poolfd, &cmd) == -1) {
+#else
 		if (send (poolfd, &cmd, sizeof (cmd), MSG_NOSIGNAL) == -1) {
+#endif
 			// errno inherited from send()
 			// let SIGPIPE be reported as EPIPE
-			close (poolfd);
+			tlspool_close_poolhandle (poolfd);
 			return -1;
 		}
 
 		/* receive and process the response */
+#ifdef WINDOWS_PORT
+		if (np_recv_command(poolfd, &cmd) == -1) {
+#else
 		if (recv (poolfd, &cmd, sizeof (cmd), MSG_NOSIGNAL) == -1) {
+#endif
 			// Let SIGPIPE be reported as EPIPE
 			// errno inherited from recv()
-			close (poolfd);
+			tlspool_close_poolhandle (poolfd);
 			return -1;
 		}
-//DEBUG// printf ("DEBUG: LIDENTRY callback command 0x%08lx with cbid=%d and flags 0x%08lx\n", cmd.pio_cmd, cmd.pio_cbid, cmd.pio_data.pioc_lidentry.flags);
+ printf ("DEBUG: LIDENTRY callback command 0x%08lx with cbid=%d and flags 0x%08lx\n", cmd.pio_cmd, cmd.pio_cbid, cmd.pio_data.pioc_lidentry.flags);
 		switch (cmd.pio_cmd) {
 		case PIOC_LIDENTRY_CALLBACK_V2:
 			cberr = (*cb) (&cmd.pio_data.pioc_lidentry, data);
@@ -116,7 +140,7 @@
 		case PIOC_ERROR_V2:
 			errno = cmd.pio_data.pioc_error.tlserrno;
 			syslog (LOG_INFO, "TLS Pool error to tlspool_localid_service(): %s", cmd.pio_data.pioc_error.message);
-			close (poolfd);
+			tlspool_close_poolhandle (poolfd);
 			return -1;
 		default:
 			errno = EPROTO;
@@ -132,9 +156,10 @@
 			// bounce the error back to us so we can report it too
 		}
 	}
-
+#ifndef WINDOWS_PORT
 	/* Never end up here... */
 	pthread_cleanup_pop (1);
+#endif
 	return 0;
 }
 
diff -Naur a/lib/libtlspool_pinentry.c b/lib/libtlspool_pinentry.c
--- a/lib/libtlspool_pinentry.c	2016-08-24 08:57:20.000000000 +0200
+++ b/lib/libtlspool_pinentry.c	2016-10-01 23:38:39.000000000 +0200
@@ -25,9 +25,9 @@
 
 /* Cleanup routine */
 static void tlspool_pin_service_closepool (void *poolfdptr) {
-	int poolfd = * (int *) poolfdptr;
-	if (poolfd >= 0) {
-		close (poolfd);
+	pool_handle_t poolfd = * (pool_handle_t  *) poolfdptr;
+	if (poolfd != INVALID_POOL_HANDLE) {
+		tlspool_close_poolhandle (poolfd);
 	}
 }
 
@@ -54,10 +54,21 @@
  * This function returns -1 on error, or 0 on success.
  */
 int tlspool_pin_service (char *path, uint32_t regflags, int responsetimeout_usec, void (*cb) (struct pioc_pinentry *entry, void *data), void *data) {
+#ifdef WINDOWS_PORT
+printf("tlspool_pin_service(%s, %d, %d, %p, %p)\n", path, regflags, responsetimeout_usec, cb, data);
+#else
 	struct sockaddr_un sun;
-	int poolfd = -1;
+#endif
+	pool_handle_t poolfd = INVALID_POOL_HANDLE;;
 	struct tlspool_command cmd;
 
+#ifdef WINDOWS_PORT
+	poolfd = open_named_pipe ((LPCTSTR) path);
+	printf ("DEBUG: poolfd = %d\n", poolfd);
+	if (poolfd == INVALID_POOL_HANDLE) {
+		return -1;
+	}
+#else
 	/* Access the TLS Pool socket */
 	if (path == NULL) {
 		path = tlspool_configvar (NULL, "daemon_pidfile");
@@ -82,6 +93,7 @@
 		poolfd = -1;
 		return -1;
 	}
+#endif
 
 	/* Prepare command structure */
 	memset (&cmd, 0, sizeof (cmd));	/* Do not leak old stack info */
@@ -95,10 +107,14 @@
 
 		/* send the request or, when looping, the callback result */
 //DEBUG// printf ("DEBUG: PINENTRY command 0x%08lx with cbid=%d and flags 0x%08lx\n", cmd.pio_cmd, cmd.pio_cbid, cmd.pio_data.pioc_pinentry.flags);
+#ifdef WINDOWS_PORT
+		if (np_send_command(poolfd, &cmd) == -1) {
+#else
 		if (send (poolfd, &cmd, sizeof (cmd), MSG_NOSIGNAL) == -1) {
+#endif
 			// errno inherited from send()
 			// let SIGPIPE be reported as EPIPE
-			close (poolfd);
+			tlspool_close_poolhandle (poolfd);
 			return -1;
 		}
 
@@ -108,10 +124,14 @@
 				sizeof (cmd.pio_data.pioc_pinentry.pin));
 
 		/* receive and process the response */
+#ifdef WINDOWS_PORT
+		if (np_recv_command(poolfd, &cmd) == -1) {
+#else
 		if (recv (poolfd, &cmd, sizeof (cmd), MSG_NOSIGNAL) == -1) {
+#endif
 			// Let SIGPIPE be reported as EPIPE
 			// errno inherited from recv()
-			close (poolfd);
+			tlspool_close_poolhandle (poolfd);
 			return -1;
 		}
 //DEBUG// printf ("DEBUG: PINENTRY callback command 0x%08lx with cbid=%d and flags 0x%08lx\n", cmd.pio_cmd, cmd.pio_cbid, cmd.pio_data.pioc_pinentry.flags);
@@ -123,17 +143,19 @@
 		case PIOC_ERROR_V2:
 			errno = cmd.pio_data.pioc_error.tlserrno;
 			syslog (LOG_INFO, "TLS Pool error to tlspool_localid_service(): %s", cmd.pio_data.pioc_error.message);
-			close (poolfd);
+			tlspool_close_poolhandle (poolfd);
 			return -1;
 		default:
 			errno = EPROTO;
-			close (poolfd);
+			tlspool_close_poolhandle (poolfd);
 			return -1;
 		}
 	}
 
+#ifndef WINDOWS_PORT
 	/* Never end up here... */
 	pthread_cleanup_pop (1);
+#endif
 	return 0;
 }
 
diff -Naur a/lib/Makefile b/lib/Makefile
--- a/lib/Makefile	2016-08-24 08:57:20.000000000 +0200
+++ b/lib/Makefile	2016-10-02 00:12:16.898188000 +0200
@@ -1,7 +1,6 @@
-ifdef WINVER
-TARGETS = libtlspool.dll libtlspool.lib
-else
 TARGETS = libtlspool.so libtlspool.a
+ifdef WINVER
+TARGETS += libtlspool.dll libtlspool.lib
 endif
 
 #
@@ -23,18 +22,13 @@
 
 PREFIX ?= /usr/local
 
-ifdef WINVER
-# TODO libtlspool_lidentry and libtlspool_pinentry
-libtlspool_OBJS = libtlspool.o
-else
 libtlspool_OBJS = libtlspool.o libtlspool_lidentry.o libtlspool_pinentry.o libtlspool_configvar.o
-endif
 
 OBJS = $(libtlspool_OBJS)
 
 ifdef WINVER
 CFLAGS += -D_WIN32_WINNT=0x0600 -I ../include/windows
-libtlspool_OBJS += windows/syslog.o windows/socketpair.o
+libtlspool_OBJS += windows/syslog.o windows/socketpair.o windows/namedpipe.o
 LIBS += -lkernel32 -ladvapi32 -lmsvcrt -lwsock32 -lws2_32
 endif
 
@@ -75,13 +69,13 @@
 anew: clean all
 
 install: all
+	install libtlspool.so libtlspool.a "$(DESTDIR)$(PREFIX)/lib/"
 ifdef WINVER
 	install libtlspool.dll libtlspool.lib "$(DESTDIR)$(PREFIX)/bin/"
 	mkdir -p "$(DESTDIR)$(PREFIX)/include/tlspool"
 	install ../include/tlspool/starttls.h "$(DESTDIR)$(PREFIX)/include/tlspool"
 	install ../include/tlspool/commands.h "$(DESTDIR)$(PREFIX)/include/tlspool"	
 else	
-	install libtlspool.so libtlspool.a "$(DESTDIR)$(PREFIX)/lib/"
 	@echo '#'
 	@echo '# Python libraries not yet installed'
 	@echo '#'
@@ -91,13 +85,13 @@
 	#DIY# @$(foreach w,$(WRAPPERS),$(MAKE) DESTDIR=$(DESTDIR) PREFIX=$(PREFIX) -C '$(w)' install && ) echo Wrappers installed for $(WRAPPERS)
 
 uninstall:
+	rm -f "$(DESTDIR)$(PREFIX)/lib/libtlspool.so"
+	rm -f "$(DESTDIR)$(PREFIX)/lib/libtlspool.a"
 ifdef WINVER
 	rm -f "$(DESTDIR)$(PREFIX)/bin/libtlspool.dll"
 	rm -f "$(DESTDIR)$(PREFIX)/bin/libtlspool.lib"
 	rm -rf "$(DESTDIR)$(PREFIX)/include/tlspool/"
 else
-	rm -f "$(DESTDIR)$(PREFIX)/lib/libtlspool.so"
-	rm -f "$(DESTDIR)$(PREFIX)/lib/libtlspool.a"
 	@echo '#'
 	@echo '# Python libraries not yet removed'
 	@echo '#'
diff -Naur a/lib/windows/namedpipe.c b/lib/windows/namedpipe.c
--- a/lib/windows/namedpipe.c	1970-01-01 01:00:00.000000000 +0100
+++ b/lib/windows/namedpipe.c	2016-10-01 16:59:01.000000000 +0200
@@ -0,0 +1,148 @@
+#include "whoami.h"
+#include <stdio.h>
+#include <tlspool/starttls.h>
+#include <tlspool/commands.h>
+#include <winsock2.h>
+
+#define _tprintf printf
+pool_handle_t open_named_pipe (LPCTSTR lpszPipename)
+{
+	HANDLE hPipe;
+	//struct tlspool_command chBuf;
+	BOOL   fSuccess = FALSE;
+	DWORD  dwMode;
+
+	// Try to open a named pipe; wait for it, if necessary.
+
+	while (1)
+	{
+		hPipe = CreateFile(
+			lpszPipename,   // pipe name
+			GENERIC_READ |  // read and write access
+			GENERIC_WRITE,
+			0,              // no sharing
+			NULL,           // default security attributes
+			OPEN_EXISTING,  // opens existing pipe
+			FILE_FLAG_OVERLAPPED, // overlapped
+			NULL);          // no template file
+
+		// Break if the pipe handle is valid.
+		if (hPipe != INVALID_POOL_HANDLE)
+			break;
+
+		// Exit if an error other than ERROR_PIPE_BUSY occurs.
+		if (GetLastError() != ERROR_PIPE_BUSY)
+		{
+			_tprintf(TEXT("Could not open pipe. GLE=%d\n"), GetLastError());
+			return INVALID_POOL_HANDLE;
+		}
+
+		// All pipe instances are busy, so wait for 20 seconds.
+		if (!WaitNamedPipe(lpszPipename, 20000))
+		{
+			printf("Could not open pipe: 20 second wait timed out.");
+			return INVALID_POOL_HANDLE;
+		}
+	}
+	// The pipe connected; change to message-read mode.
+	dwMode = PIPE_READMODE_MESSAGE;
+	fSuccess = SetNamedPipeHandleState(
+		hPipe,    // pipe handle
+		&dwMode,  // new pipe mode
+		NULL,     // don't set maximum bytes
+		NULL);    // don't set maximum time
+	if (!fSuccess)
+	{
+		_tprintf(TEXT("SetNamedPipeHandleState failed. GLE=%d\n"), GetLastError());
+		return INVALID_POOL_HANDLE;
+	}
+	ULONG ServerProcessId;
+	if (GetNamedPipeServerProcessId(hPipe, &ServerProcessId)) {
+		printf("GetNamedPipeServerProcessId: ServerProcessId = %ld\n", ServerProcessId);
+	} else {
+		_tprintf(TEXT("GetNamedPipeServerProcessId failed. GLE=%d\n"), GetLastError());
+	}
+	return hPipe;
+}
+
+
+int np_send_command(pool_handle_t poolfd, struct tlspool_command *cmd) {
+	DWORD  cbToWrite, cbWritten;
+	OVERLAPPED overlapped;
+	BOOL fSuccess;
+
+	/* Send the request */
+	// Send a message to the pipe server.
+
+	cbToWrite = sizeof (struct tlspool_command);
+	_tprintf(TEXT("Sending %d byte cmd\n"), cbToWrite);
+
+	memset(&overlapped, 0, sizeof(overlapped));
+	overlapped.hEvent = CreateEvent(NULL, TRUE, FALSE, NULL);
+
+	fSuccess = WriteFile(
+		poolfd,                // pipe handle
+		cmd,                   // cmd message
+		cbToWrite,             // cmd message length
+		NULL,                  // bytes written
+		&overlapped);          // overlapped
+
+	if (!fSuccess && GetLastError() == ERROR_IO_PENDING )
+	{
+// printf ("DEBUG: Write I/O pending\n");
+		fSuccess = WaitForSingleObject(overlapped.hEvent, INFINITE) == WAIT_OBJECT_0;
+	}
+
+	if (fSuccess) {
+		fSuccess = GetOverlappedResult(poolfd, &overlapped, &cbWritten, TRUE);
+	}
+
+	if (!fSuccess)
+	{
+		_tprintf(TEXT("WriteFile to pipe failed. GLE=%d\n"), GetLastError());
+		return -1;
+	} else {
+printf ("DEBUG: Wrote %ld bytes to pipe\n", cbWritten);
+	}
+printf("DEBUG: Message sent to server, receiving reply as follows:\n");
+	return 0;
+}
+
+
+int np_recv_command(pool_handle_t poolfd, struct tlspool_command *cmd) {
+	DWORD cbToRead, cbRead;
+	OVERLAPPED overlapped;
+	BOOL fSuccess;
+
+	cbToRead = sizeof (struct tlspool_command);
+	memset(&overlapped, 0, sizeof(overlapped));
+	overlapped.hEvent = CreateEvent(NULL, TRUE, FALSE, NULL);
+
+	// Read from the pipe.
+	fSuccess = ReadFile(
+		poolfd,       // pipe handle
+		cmd,          // buffer to receive reply
+		cbToRead,     // size of buffer
+		NULL,         // number of bytes read
+		&overlapped); // not overlapped
+
+	if (!fSuccess && GetLastError() == ERROR_IO_PENDING )
+	{
+printf ("DEBUG: Read I/O pending\n");
+		fSuccess = WaitForSingleObject(overlapped.hEvent, INFINITE) == WAIT_OBJECT_0;
+	}
+
+	if (fSuccess) {
+		fSuccess = GetOverlappedResult(poolfd, &overlapped, &cbRead, TRUE);
+	}
+
+	if (!fSuccess)
+	{
+		_tprintf(TEXT("ReadFile from pipe failed. GLE=%d\n"), GetLastError());
+		return -1;
+	} else {
+printf ("DEBUG: Read %ld bytes from pipe\n", cbRead);
+	}
+	return 0;
+}
+
diff -Naur a/src/service.c b/src/service.c
--- a/src/service.c	2016-08-24 08:57:20.000000000 +0200
+++ b/src/service.c	2016-10-02 00:02:00.000000000 +0200
@@ -505,7 +505,7 @@
    return fPendingIO;
 }
 
-static int np_send_command(struct tlspool_command *cmd) {
+static int np_send_command1(struct tlspool_command *cmd) {
 	DWORD  cbToWrite, cbWritten;
 	OVERLAPPED overlapped;
 	BOOL fSuccess;
@@ -555,7 +555,7 @@
 	memset (&cmd->cmd.pio_ancil_data,
 			0,
 			sizeof (cmd->cmd.pio_ancil_data));
-	return !np_send_command(&cmd->cmd) ? 1 : 0;
+	return !np_send_command1(&cmd->cmd) ? 1 : 0;
 #else /* WINDOWS_PORT */
 	char anc [CMSG_SPACE(sizeof (int))];
 	struct iovec iov;
